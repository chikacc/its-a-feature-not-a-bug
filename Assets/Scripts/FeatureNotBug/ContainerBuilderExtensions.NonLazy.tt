<#@ assembly name="$(SolutionDir)\Library\ScriptAssemblies\VContainer.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="VContainer" #>
<# var lifetimes = Enum.GetNames(typeof(Lifetime)); #>
// <auto-generated/>
using System;
using VContainer;
using VContainer.Unity;

namespace FeatureNotBug;

public static partial class ContainerBuilderExtensions {
    public static void UseNonLazy(this IContainerBuilder builder, Action<NonLaziesBuilder> configuration) {
        configuration(new NonLaziesBuilder(builder));
    }

    public readonly struct NonLaziesBuilder {
        readonly IContainerBuilder _containerBuilder;

        public NonLaziesBuilder(IContainerBuilder containerBuilder) {
            _containerBuilder = containerBuilder;
        }
<# for (var i = 0; i < 4; ++i) { #>
<# for (var j = 0; j < lifetimes.Length; ++j) { #>
<# var lifetime = lifetimes[j]; #>
<# var generics = string.Join(", ", Enumerable.Range(0, i).Select(x => $"Interface{x + 1}").Append("TImplement")); #>
<# var interfaces = string.Join(", ", Enumerable.Range(0, i).Select(x => $"Interface{x + 1}")); #>

<# if (string.IsNullOrEmpty(interfaces)) { #>
        public RegistrationBuilder Add<#= lifetime #><<#= generics #>>() {
<# } else { #>
        public RegistrationBuilder Add<#= lifetime #><<#= generics #>>() where TImplement : <#= interfaces #> {
<# } #>
            _containerBuilder.RegisterBuildCallback(static resolver => resolver.Resolve<TImplement>());
            return _containerBuilder.Register<<#= generics #>>(Lifetime.<#= lifetime #>);
        }
<# } #>
<# } #>
<# for (var i = 0; i < lifetimes.Length; ++i) { #>
<# var lifetime = lifetimes[i]; #>

        public RegistrationBuilder Add<#= lifetime #><TInterface>(Func<IObjectResolver, TInterface> implementationConfiguration) where TInterface : class {
            _containerBuilder.RegisterBuildCallback(static resolver => resolver.Resolve<TInterface>());
            return _containerBuilder.Register<TInterface>(implementationConfiguration, Lifetime.<#= lifetime #>);
        }
<# } #>
<# for (var i = 0; i < lifetimes.Length; ++i) { #>
<# var lifetime = lifetimes[i]; #>
<# if (lifetime == "Transient") continue; #>

        public RegistrationBuilder Add<#= lifetime #>EntryPoint<T>() {
            _containerBuilder.RegisterBuildCallback(static resolver => resolver.Resolve<T>());
            return _containerBuilder.RegisterEntryPoint<T>(Lifetime.<#= lifetime #>);
        }
<# } #>
    }
}
